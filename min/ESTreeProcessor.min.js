const ESTreeProcessor=function(){"use strict";const e="Global",s="Function",t="Block",r="Let",a="Const",o="Var";class i{parent;variables={};type;constructor(e,s){this.type=e,this.parent=s,this.variables={}}declare(t,i,n=void 0){switch(this.checkAlreadyDeclared(i,t),t){case r:case a:this.variables[i]={type:t,value:n};break;case o:{let r=this;for(;r;)r.type===s||r.type===e?(r.variables[i]={type:t,value:n},r=void 0):r=r.parent;break}default:throw new SyntaxError(`Unexpected variable declaration type: ${t}`)}}checkAlreadyDeclared(t,i){let n=this;for(;n;){if(n.variables.hasOwnProperty(t)&&(i===a||i===r||n.variables[t].type!==o))throw new SyntaxError(`Identifier '${t}' has already been declared`);n=n.type===s||n.type===e?void 0:n.parent}}setValue(e,s){const t=this.getReference(e,!0);if(!t)throw new ReferenceError(`${e} is not defined.`);if(t.type===a)throw new TypeError(`Assignment to constant variable: ${e}`);return t.value=s}getValue(e){const s=this.getReference(e);return s?.value}getReference(s){let t=this;for(;t;){if(t.variables.hasOwnProperty(s))return t.variables[s];t=t.type===e?void 0:t.parent}}createChildScope(e){return new i(e,this)}}class n{}class c extends n{}class p extends n{}class l extends n{value;constructor(e){super(),this.value=e}}class d{}class h{}class b{process(s,t){return this.globalVariables={...t},{output:this.processNode(s,new i(e)),variables:this.globalVariables}}processNode(e,s){let t;switch(e.type){case esprima.Syntax.Program:t=this.processProgram(e,s);break;case esprima.Syntax.ExpressionStatement:t=this.processNode(e.expression,s);break;case esprima.Syntax.Literal:t=b.processLiteral(e,s);break;case esprima.Syntax.MemberExpression:t=this.processMemberExpression(e,s);break;case esprima.Syntax.BinaryExpression:t=this.processBinaryExpression(e,s);break;case esprima.Syntax.VariableDeclaration:t=this.processVariableDeclaration(e,s);break;case esprima.Syntax.VariableDeclarator:t=this.processVariableDeclarator(e,s);break;case esprima.Syntax.CallExpression:t=this.processCallExpression(e,s);break;case esprima.Syntax.AssignmentExpression:t=this.processAssigmentExpression(e,s);break;case esprima.Syntax.Identifier:t=b.processIdentifier(e,s);break;case esprima.Syntax.IfStatement:t=this.processIfStatement(e,s);break;case esprima.Syntax.BlockStatement:t=this.processBlockStatement(e,s);break;case esprima.Syntax.EmptyStatement:break;case esprima.Syntax.TemplateLiteral:t=this.processTemplateLiteral(e,s);break;case esprima.Syntax.NewExpression:t=this.processNewExpression(e,s);break;case esprima.Syntax.FunctionDeclaration:t=this.processFunctionDeclaration(e,s);break;case esprima.Syntax.ReturnStatement:t=this.processReturnStatement(e,s);break;case esprima.Syntax.LogicalExpression:t=this.processLogicalExpression(e,s);break;case esprima.Syntax.UnaryExpression:t=this.processUnaryExpression(e,s);break;case esprima.Syntax.ArrayExpression:t=this.processArrayExpression(e,s);break;case esprima.Syntax.ConditionalExpression:t=this.processConditionalExpression(e,s);break;case esprima.Syntax.ObjectExpression:t=this.processObjectExpression(e,s);break;case esprima.Syntax.FunctionExpression:t=this.processFunctionExpression(e,s);break;case esprima.Syntax.ArrowFunctionExpression:t=this.processArrowFunctionExpression(e,s);break;case esprima.Syntax.ChainExpression:t=this.processChainExpression(e,s);break;case esprima.Syntax.UpdateExpression:t=this.processUpdateExpression(e,s);break;case esprima.Syntax.ForStatement:t=this.processForStatement(e,s);break;case esprima.Syntax.TryStatement:t=this.processTryStatement(e,s);break;case esprima.Syntax.BreakStatement:t=b.processBreakStatement();break;case esprima.Syntax.ContinueStatement:t=b.processContinueStatement();break;case esprima.Syntax.DebuggerStatement:t=b.processDebuggerStatement();break;case esprima.Syntax.SwitchStatement:t=this.processSwitchStatement(e,s);break;default:throw new SyntaxError(`Unexpected node type: ${e.type}`)}return t}processSwitchStatement(e,s){const r=this.processNode(e.discriminant,s);let a,o=-1,i=-1;for(let t=0;t<e.cases.length&&-1===o;t++){const a=e.cases[t];a.test?this.processNode(a.test,s)===r&&(o=t):i=t}if(-1===o&&(o=i),o>-1){const r=s.createChildScope(t);for(let s=o;s<e.cases.length&&!(a instanceof n);s++){let t;const o=e.cases[s];for(let e=0;e<o.consequent.length&&!(t instanceof n);e++)t=this.processNode(o.consequent[e],r),t instanceof c||t instanceof p||(a=t)}}return a}static processDebuggerStatement(){return new d}processTryStatement(e,t){let r;try{r=this.processNode(e.block,t)}catch(r){const a=t.createChildScope(s);e.handler.param.returnName=!0,a.declare(o,this.processNode(e.handler.param,a),r),this.processNode(e.handler.body,a)}finally{e.finalizer&&this.processNode(e.finalizer,t)}return r}processObjectExpression(e,s){const t={};return e.properties.forEach((r=>{r.key.returnName=!e.computed;const a=this.processNode(r.key,s);t[a]=this.processNode(r.value,s)})),t}processConditionalExpression(e,s){return this.processNode(e.test,s)?this.processNode(e.consequent,s):this.processNode(e.alternate,s)}processArrayExpression(e,s){return e.elements.map((e=>this.processNode(e,s)))}setScopeValue(e,s,t){switch(e.type){case esprima.Syntax.MemberExpression:{const r=this.processNode(e.object,t);e.property.returnName=!0;r[this.processNode(e.property,t)]=s;break}case esprima.Syntax.Identifier:t.setValue(e.name,s);break;default:throw new SyntaxError(`Unexpected target node type in setValue(): ${e.type}`)}return s}processUpdateExpression(e,s){const t=this.processNode(e.argument,s);let r;switch(e.operator){case"++":r=this.setScopeValue(e.argument,t+1,s);break;case"--":r=this.setScopeValue(e.argument,t-1,s);break;default:throw new SyntaxError(`Unexpected update expression operator: ${e.operator}`)}return e.prefix?r:t}processForStatement(e,s){let t;for(this.processNode(e.init,s);this.processNode(e.test,s);){if(t=this.processNode(e.body,s),t instanceof n){t instanceof l&&(t=t.value);break}this.processNode(e.update,s)}return t}processUnaryExpression(e,s){let t;switch(e.operator){case"!":t=!this.processNode(e.argument,s);break;case"~":t=~this.processNode(e.argument,s);break;case"-":t=-this.processNode(e.argument,s);break;case"typeof":t=typeof this.processNode(e.argument,s);break;default:throw new SyntaxError(`Unexpected unary expression operator: ${e.operator}`)}return t}processLogicalExpression(e,s){let t;switch(e.operator){case"&&":t=this.processNode(e.left,s)&&this.processNode(e.right,s);break;case"||":t=this.processNode(e.left,s)||this.processNode(e.right,s);break;case"??":t=this.processNode(e.left,s)??this.processNode(e.right,s);break;default:throw new SyntaxError(`Unexpected logical expression operator: ${e.operator}`)}return t}processReturnStatement(e,s){const t=this.processNode(e.argument,s);return new l(t)}static processContinueStatement(){return new p}static processBreakStatement(){return new c}processArrowFunctionExpression(e,t){return(...r)=>{const a=r.map((e=>({type:esprima.Syntax.Literal,value:e}))),i=t.createChildScope(s);for(let s=0;s<Math.min(a.length,e.params.length);s++){const t=e.params[s];t.returnName=!0,i.declare(o,this.processNode(t,i),this.processNode(a[s],i))}let n=this.processNode(e.body,i);return n instanceof l&&(n=n.value),n}}processChainExpression(e,s){let t;switch(e.expression.type){case esprima.Syntax.CallExpression:case esprima.Syntax.MemberExpression:t=this.processNode(e.expression,s);break;default:throw new SyntaxError(`Unexpected chain expression type: ${e.expression.type}`)}return t instanceof h&&(t=void 0),t}processFunctionDeclaration(e,t){const r=(...r)=>{const a=r.map((e=>({type:esprima.Syntax.Literal,value:e}))),i=t.createChildScope(s);for(let s=0;s<Math.min(a.length,e.params.length);s++){const t=e.params[s];t.returnName=!0,i.declare(o,this.processNode(t,i),this.processNode(a[s],i))}let n=this.processNode(e.body,i);return n instanceof l&&(n=n.value),n};if(e.id){e.id.returnName=!0;const s=this.processNode(e.id,t);t.declare(o,s,r)}return r}processFunctionExpression(e,t){return(...r)=>{const a=r.map((e=>({type:esprima.Syntax.Literal,value:e}))),i=t.createChildScope(s);for(let s=0;s<Math.min(a.length,e.params.length);s++){const t=e.params[s];t.returnName=!0,i.declare(o,this.processNode(t,i),this.processNode(a[s],i))}let n=this.processNode(e.body,i);return n instanceof l&&(n=n.value),n}}processProgram(e,s){let t;return Object.keys(this.globalVariables).forEach((e=>{s.declare(r,e,this.globalVariables[e])})),e.body.forEach((e=>{t=this.processNode(e,s)})),t}processNewExpression(e,s){const t=e.arguments.map((e=>this.processNode(e,s)));return Reflect.construct(this.processNode(e.callee,s),t)}processTemplateLiteral(e,s){let t="";for(let r=0;r<e.quasis.length;r++)t+=e.quasis[r].value.cooked,e.quasis[r].tail||(t+=this.processNode(e.expressions[r],s));return t}processBlockStatement(e,s){let r;const a=s.createChildScope(t);for(let s=0;s<e.body.length;s++){const t=e.body[s],o=this.processNode(t,a);if(o instanceof n){o instanceof l&&(r=o);break}o instanceof d||(r=o)}return r}processIfStatement(e,s){let t;return this.processNode(e.test,s)?t=this.processNode(e.consequent,s):e.alternate&&(t=this.processNode(e.alternate,s)),t}static processLiteral(e){return e.value}static processIdentifier(e,s){let t;return t=e.returnName?e.name:s.getValue(e.name),t}getMemberExpressionObject(e,s){let t;switch(e.object.type){case esprima.Syntax.Identifier:t=s.getValue(e.object.name);break;case esprima.Syntax.CallExpression:case esprima.Syntax.MemberExpression:t=this.processNode(e.object,s);break;default:throw new SyntaxError(`Unexpected member expression object type: ${e.object.type}`)}return t}processMemberExpression(e,s){let t;const r=this.getMemberExpressionObject(e,s);if(null==r&&e.optional)t=new h;else if(null!=r||null==r&&!e.optional){e.property.returnName=!e.computed;t=r[this.processNode(e.property,s)]}return t}doBinaryExpression(e,s,t){return s(this.processNode(e.left,t),this.processNode(e.right,t))}static add(e,s){return e+s}static subtract(e,s){return e-s}static multiply(e,s){return e*s}static divide(e,s){return e/s}static mod(e,s){return e%s}static power(e,s){return e**s}processBinaryExpression(e,s){let t;const r=t=>this.doBinaryExpression(e,t,s);switch(e.operator){case"+":t=r(b.add);break;case"-":t=r(b.subtract);break;case"*":t=r(b.multiply);break;case"/":t=r(b.divide);break;case"%":t=r(b.mod);break;case"**":t=r(b.power);break;case">":t=r(((e,s)=>e>s));break;case"<":t=r(((e,s)=>e<s));break;case"==":t=r(((e,s)=>e==s));break;case"===":t=r(((e,s)=>e===s));break;case">=":t=r(((e,s)=>e>=s));break;case"<=":t=r(((e,s)=>e<=s));break;case"!=":t=r(((e,s)=>e!=s));break;case"!==":t=r(((e,s)=>e!==s));break;case"^":t=r(b.bitwiseXOR);break;case"|":t=r(b.bitwiseOR);break;case"&":t=r(b.bitwiseAND);break;case">>":t=r(b.bitwiseRightShift);break;case"<<":t=r(b.bitwiseLeftShift);break;case">>>":t=r(b.bitwiseUnsignedRightShift);break;default:throw new SyntaxError(`Unexpected binary expression operator: ${e.operator}`)}return t}processVariableDeclaration(e,s){switch(e.kind){case"let":case"const":case"var":e.declarations.forEach((t=>{t.kind=e.kind,this.processNode(t,s)}));break;default:throw new SyntaxError(`Unexpected variable declaration kind: ${e.type}`)}}processVariableDeclarator(e,s){switch(e.id.type){case esprima.Syntax.Identifier:{e.id.returnName=!0;const t=this.processNode(e.id,s),i=e.init?this.processNode(e.init,s):void 0;let n;switch(e.kind){case"let":n=r;break;case"const":n=a;break;case"var":n=o;break;default:throw new TypeError(`Unexpected variable declaration kind: ${e.kind}`)}s.declare(n,t,i);break}case esprima.Syntax.ObjectPattern:{const t=this.processNode(e.init,s);e.id.properties.forEach((i=>{i.key.returnName=!0;const n=this.processNode(i.key,s);i.value.returnName=!0;const c=this.processNode(i.value,s),p=t[c];let l;switch(e.kind){case"let":l=r;break;case"const":l=a;break;case"var":l=o;break;default:throw new TypeError(`Unexpected variable declaration kind: ${e.kind}`)}s.declare(l,n,p)}));break}default:throw new SyntaxError(`Unexpected variable declarator id type: ${e.id.type}`)}}processCallExpression(e,s){const{callee:t}=e;let r,a,o;switch(t.type){case esprima.Syntax.MemberExpression:if(a=this.processNode(t.object,s),null==a){if(!t.optional)throw new SyntaxError("Callee object not found in call expression.");o=new h}else a instanceof h?o=new h:r=a[t.property.name];break;case esprima.Syntax.Identifier:r=s.getValue(t.name);break;default:throw new SyntaxError(`Unexpected callee type in call expression: ${t.type}`)}if(!(o instanceof h))if(null==r){if(!e.optional){let e;switch(t.type){case esprima.Syntax.Identifier:e=t.name;break;case esprima.Syntax.MemberExpression:t.property.returnName=!0,e=this.processNode(t.property)}throw new SyntaxError(`Method not found: ${e}`)}o=new h}else{const t=e.arguments.map((e=>this.processNode(e,s)));o=r.call(a,...t)}return o}doAssignmentExpression(e,s,t){let r,a;switch(e.left.type){case esprima.Syntax.Identifier:a=t.getValue(e.left.name),r=this.setScopeValue(e.left,s(a,this.processNode(e.right,t)),t);break;case esprima.Syntax.MemberExpression:{const o=this.getMemberExpressionObject(e.left,t),i=this.processNode(e.left.property,t);a=o[i],r=o[i]=s(a,this.processNode(e.right,t));break}default:throw new SyntaxError(`Unexpected type on left side of assignment expression: ${e.left.type}`)}return r}static nullishCoalesce(e,s){return e??s}static or(e,s){return e||s}static and(e,s){return e&&s}static bitwiseAND(e,s){return e&s}static bitwiseOR(e,s){return e|s}static bitwiseXOR(e,s){return e^s}static bitwiseLeftShift(e,s){return e<<s}static bitwiseRightShift(e,s){return e>>s}static bitwiseUnsignedRightShift(e,s){return e>>>s}processAssigmentExpression(e,s){let t;const r=t=>this.doAssignmentExpression(e,t,s);switch(e.operator){case"=":t=this.setScopeValue(e.left,this.processNode(e.right,s),s);break;case"+=":t=r(b.add);break;case"-=":t=r(b.subtract);break;case"*=":t=r(b.multiply);break;case"/=":t=r(b.divide);break;case"%=":t=r(b.mod);break;case"**=":t=r(b.power);break;case"??=":t=r(b.nullishCoalesce);break;case"||=":t=r(b.or);break;case"&&=":t=r(b.and);break;case"<<=":t=r(b.bitwiseLeftShift);break;case">>=":t=r(b.bitwiseRightShift);break;case">>>=":t=r(b.bitwiseUnsignedRightShift);break;case"&=":t=r(b.bitwiseAND);break;case"|=":t=r(b.bitwiseOR);break;case"^=":t=r(b.bitwiseXOR);break;default:throw new SyntaxError(`Unexpected assigment expression operator: ${e.operator}`)}return t}}return b}();